МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ  УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»




ЗВІТ
з лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Розробка IoT клієнта (бізнес-логіки та функцій налаштування)»





Виконала                    Перевірив
ст. гр. ПЗПІ-22-6           ст. викладач
Лисенко А.М.                Сокорчук І.П.





Харків 2024
1 РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)
2. Мета роботи:
Розробити програмне забезпечення для IoT або SmartDevice пристрою, створеного на базі будь-якої поширеної на сьогодні платформи, придатної для реалізації вбудованих систем.
3. Хід роботи:
3.1 Розробити будову програмного забезпечення ІоТ клієнта.
IoT застосунок було розроблено на мові програмування C#. Він генерує інформацію (показники рівня газу, температури, тиску) від імені сенсорів. Після цього відбувається визначення рівня загрози на основі сенсорних показників. Далі ІоТ клієнт надсилає дані до сервера через MQTT-брокер для подальшої обробки. Також для реалізації деякий частин логіки було реалізовано взаємодію з бекенд-сервісом для отримання метаданих про сенсори, їх стан (активність сенсора) та дані, що вони передають.
Архітектурна схема:
    • Симуляція даних: генерується інформація, яку передають активні сенсори.
    • Збір активних сенсорів: через HTTP-запит до бекенду отримується список ідентифікаторів активних сенсорів.
    • Обробка даних: дані сенсорів аналізуються для визначення рівня загрози.
    • Публікація даних: дані та події публікуються через MQTT-брокер для їх подальшого отримання сервером.
Було використано такі мережеві технології, як MQTT (протокол публікації, підписки для передачі даних між пристроями) та HTTP (протокол для обміну даними з бекенд-сервісом).
3.2 Створити UML діаграму прецедентів для ІоТ клієнта.
На рисунку 1 представлено розроблену UML діаграму прецедентів для ІоТ клієнта.

Рисунок 1 - UML діаграма прецедентів

3.3 Розробити бізнес логіку (математичну обробку пов’язаних із предметною областю даних) та функції налаштування ІоТ клієнта.
Бізнес-логіка для визначення рівня загрози. Перевіряються значення даних (показник газу, температура, тиск) і, якщо вони перевищують певні пороги, формуються події з відповідним рівнем серйозності.
Сформований алгоритм:
    1. Для кожного параметра визначаються коефіцієнти важливості (можна налаштувати конкретні значення).
    2. Після отримання даних з сенсора, відбувається нормалізація значень:
    (значення-мінімальне значення)/(максимальне значення-мінімальне значення)
    3. Розраховується загальний бал на основі нормалізованих значень та показників важливості:
    totalScore = (normalizedGas * gasWeight) + (normalizedTemperature * temperatureWeight) + (normalizedPressure * pressureWeight)
    4. Визначається рівень загрози на основі загального балу: 
        • якщо загальний бал перевищує значення 0,75 – високий рівень загрози;
        • якщо загальний бал у межах від 0,5 до 0,75 – середній рівень загрози;
        • якщо загальний бал нижче 0,5 – низький рівень загрози;
При фіксуванні подій високого та середнього рівня загрози IoT формує та передає подію до сервера.
До функцій налаштування ІоТ клієнта відносяться: налаштування MQTT-конфігурації, налаштування інтервалу надсилання даних до серверу, налаштування коефіцієнтів важливості для показників газу, температури, тиску. 
3.4 Створити діаграму діяльності для ІоТ клієнта.
Діаграму діяльності для ІоТ клієнта винесено у додаток А.
3.5 Створити програмну реалізацію бізнес-логіки та функцій налаштування ІоТ клієнта.
Фрагменти програмного коду з реалізацією бізнес-логіки та функцій налаштування ІоТ клієнта наведено у додатку Б.
4. Посилання на відеозапис з тестуванням ІоТ клієнта (YouTube):
https://youtu.be/8xAwBi6yFeM 
5. Посилання на репозиторій проєкту (GitHub):
https://github.com/NureLysenkoAnna/arkpz-pzpi-22-6-lysenko-anna/tree/main/Task4
6. Висновки:
У результаті виконання лабораторної роботи було розроблено програмне забезпечення для IoT клієнта, що генерує та передає показники, імітуючи роботу сенсорів для виявлення витоків газу. Також зі сторони IoT клієнта відбувається перевірка значень для визначення рівня загрози. Якщо було виявлено загрози середнього та високо рівня, відбувається передача відповідної події до сервера.
     
ДОДАТОК А
UML діаграма

Рисунок А.1 - UML діаграма діяльності для ІоТ клієнта

ДОДАТОК Б
Фрагменти програмного коду з реалізацією бізнес-логіки та функцій налаштування ІоТ клієнта

1	/// <summary>
2	/// Аналізує дані сенсора та визначає рівень загрози на основі заданих ваг та нормалізації параметрів.
3	/// </summary>
4	/// <param name="sensorData">Дані сенсора, що містять рівень газу, температуру та тиск.</param>
5	/// <returns>Рівень загрози (Low, Medium, High).</returns>
6	public static SeverityLevel AnalyzeSensorData(dynamic sensorData)
7	{
8	    // Визначаємо коефіцієнти ваги для кожного параметра
9	    double gasWeight = _settings.GasWeight;
10	    double temperatureWeight = _settings.TemperatureWeight;
11	    double pressureWeight = _settings.PressureWeight;
12	
13	    // Отримуємо значення з даних сенсора
14	    double gasLevel = sensorData.gas_level;
15	    double temperature = sensorData.temperature;
16	    double pressure = sensorData.pressure;
17	
18	    // Нормалізація значень
19	    double normalizedGas = Normalize(gasLevel, 0, 100);
20	    double normalizedTemperature = Normalize(temperature, 0, 50);
21	    double normalizedPressure = Normalize(pressure, 1, 10);
22	
23	    // Розраховуємо загальний бал на основі нормалізованих значень та ваг
24	    double totalScore = (normalizedGas * gasWeight) + (normalizedTemperature * temperatureWeight) + (normalizedPressure * pressureWeight);
25
26	    // Визначаємо рівень загрози на основі балу
27	    if (totalScore > 0.75)
28	    {
29	        return SeverityLevel.High;
30	    }
31	    else if (totalScore > 0.5)
32	    {
33	        return SeverityLevel.Medium;
34	    }
35	    else
36	    {
37	        return SeverityLevel.Low;
38	    }
39	}
40
41	/// <summary>
42	/// Нормалізує значення в заданому діапазоні.
43	/// </summary>
44	/// <param name="value">Поточне значення.</param>
45	/// <param name="minValue">Мінімальне можливе значення.</param>
46	/// <param name="maxValue">Максимальне можливе значення.</param>
47	/// <returns>Нормалізоване значення в межах від 0 до 1.</returns>
48	private static double Normalize(double value, double minValue, double maxValue)
49	{
50	    return (value - minValue) / (maxValue - minValue);
51	}
52	// Завантаження налаштувань з конфігураційного файлу.
53	var config = new ConfigurationBuilder()
54	.SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
55	.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
56	.Build();
57	
58	var settings = config.GetSection("AnalyzerSettings").Get<AnalyzerSettings>();
59	// Ініціалізація налаштувань
60	SensorDataAnalyzer.InitializeSettings(settings);
61
62	// Завантаження MQTT-параметрів з конфігурації
63	var mqttSettings = config.GetSection("MqttSettings");
64	string broker = mqttSettings["Broker"];
65	int port = int.Parse(mqttSettings["Port"]);
66	string sensorDataTopic = mqttSettings.GetSection("Topics")["SensorData"];
67	string sensorEventTopic = mqttSettings.GetSection("Topics")["SensorEvent"];
68	int sendInterval = int.Parse(mqttSettings["SendIntervalMs"]);
