МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ  УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»


ЗВІТ
з лабораторної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Розробка бази даних для серверної частини програмної системи та прикладного інтерфейсу (API)»





Виконала                    Перевірив
ст. гр. ПЗПІ-22-6           ст. викладач
Лисенко А.М.                Сокорчук І.П.





Харків 2024
1 РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)
2. Мета роботи:
Розробити базу даних для серверної частини  програмної системи та прикладного програмного інтерфейсу.
3. Хід роботи:
3.1 Розробити будову програмної системи.
Проєкт побудовано за клієнт-серверною архітектурою. Серверна частина платформи для виявлення витоків газу реалізована на ASP.NET Core. Для зберігання даних використовується реляційна база даних MS SQL. Робота з базою даних MS SQL Server відбувається через ORM, а саме Entity Framework Core. Взаємодія з клієнтами здійснюється через API, для інтеграції з IoT-сенсорами, вебінтерфейс, мобільний додаток.
Модулі серверної частини:
1. Авторизація та аутентифікація:
    • Використання JWT для безпечної авторизації та аутентифікації користувачів.
2. Модуль управління локаціями:
    • Створення, перегляд, редагування та видалення локацій.
    • Додавання користувачів до локацій, сенсорів для виявлення витоків газу.
3. Модуль управління сенсорами:
    • Створення, перегляд, редагування та видалення сенсорів.
    • Створення, перегляд, редагування та видалення перевірок сенсорів та детекторів.
    • Встановлення порогових та критичних значень для отриманих даних з сенсорів задля коректного реагування на аномальні події.
    • Перегляд стану газових мереж житлового комплексу, критичних подій.
4. Модуль обробки даних IoT-сенсорів:
    • Збір і обробка даних з сенсорів, встановлених у приміщеннях. Збираються дані про концентрацію газу (метану) у повітрі, температуру, тиск.
    • Передача за допомогою протоколів до серверної частини отриманих даних для подальшого аналізу, виявлення загроз. 
5. Модуль аналітики:
    • Аналіз отриманих даних, змін показників (концентрації газу, температури та тиску) для виявлення довгострокових тенденцій.
    • Використання алгоритмів для попередження аварій на основі аналізованих даних. 
    • Використання алгоритмів для виявлення застарілих чи неактуальних, що вимагають проведення додаткових перевірок, пристроїв для збору даних. 
    • Генерація звітів про стан газової системи, що може містити історії аномальних подій для аналізу роботи системи. 
6. Модуль сповіщень та отримання рекомендацій:
    • Надсилання оперативних повідомлень мешканцям про виявлення витоків та автоматичне інформування відповідальних керуючих осіб.
    • Надання доступу до інструкцій з комплексом дій під час надзвичайних або аварійних ситуацій.
7. Модуль адміністрування:
    • Управління користувачами.
    • Загальний моніторинг роботи серверної частини системи.
    • Налаштування зон газових мереж, алгоритмів обробки даних, проведення перевірок сенсорів, логіки моніторингу тенденцій та аномалій у показниках.
    • Отримання повідомлень про витоки газу та несправність сенсорів.
8. Модуль клієнтської частини:
    • Авторизація на платформі.
    • Отримання повідомлень про витоки газу та несправність сенсорів.
    • Отримання інструкцій при аварійних ситуаціях. 
    • Перегляд стану газових мереж.
3.2 Створити UML діаграму прецедентів для серверної частини системи.
Створена UML діаграму прецедентів винесена у додаток А.
3.3 Створити ER діаграму даних.

Рисунок 1 – ER діаграма даних

3.4 Розробити базу даних (БД) програмної системи.
У проєкті використовується Entity Framework для роботи з базою даних. Він дозволяє працювати з об'єктами C# замість SQL-запитів.
З'єднання з базою даних налаштовано в файлі appsettings.json і передається через DbContext в Program.cs.
Таблиця Users призначена для зберігання інформації про користувачів, їх ролі та пов'язані дані. Її поля та обмеження полів:
    • user_id (INT, первинний ключ, іdentity): унікальний ідентифікатор для кожного користувача, інкрементується автоматично.
    • user_name (NVARCHAR(50), NOT NULL): ім'я користувача.
    • role (NVARCHAR(30), NOT NULL): роль користувача (наприклад, мешканець, завідувач, адміністратор).
    • password (NVARCHAR(255), NOT NULL): пароль користувача.
    • email (NVARCHAR(100), NOT NULL): електронна адреса користувача.
    • phone_number (NVARCHAR(15), NULL): номер телефону користувача.
    • location_id (INT, NULL, зовнішній ключ): посилається на поле location_id у таблиці Location, що зв’язує користувача з певною локацією.
Таблиця Locations призначена для зберігання інформації про локації. Її поля та обмеження полів:
    • location_id (INT, первинний ключ, Identity): унікальний ідентифікатор локації, інкрементується автоматично.
    • name (NVARCHAR(50), NOT NULL): назва локації.
    • location_type (NVARCHAR(30), NOT NULL): тип локації.
    • floor (INT, NULL): поверх, на якому знаходиться локація.
    • area (DECIMAL(10, 2), NULL): площа локації у квадратних метрах.
Таблиця Sensors призначена для зберігання інформації про сенсори, встановлені у локаціях. Її поля та обмеження полів:
    • sensor_id (INT, первинний ключ, іdentity): унікальний ідентифікатор сенсора, автоматично інкрементується.
    • type (NVARCHAR(50), NOT NULL): тип сенсора.
    • status (NVARCHAR(30), NOT NULL): статус сенсора.
    • installation_date (DATE, NULL): дата встановлення сенсора.
    • location_id (INT, зовнішній ключ): посилається на поле location_id у таблиці Location, що асоціює сенсор із локацією.
Таблиця SensorData зберігає дані, отримані від сенсорів. Її поля та обмеження полів:
    • data_id (INT, первинний ключ, іdentity): унікальний ідентифікатор запису даних автоматично інкрементується.
    • gas_level (FLOAT, NOT NULL): рівень газу, зафіксований сенсором.
    • temperature (FLOAT, NOT NULL): температура, зафіксована сенсором.
    • pressure (FLOAT, NOT NULL): тиск, зафіксований сенсором.
    • time_stamp (DATETIME, NOT NULL): час, коли були зафіксовані дані.
    • sensor_id (INT, зовнішній ключ): ідентифікатор сенсора, що зібрав дані.
Таблиця SensorChecks використовується для зберігання інформації про перевірки датчиків. Її поля та обмеження полів:
    • check_id (INT, первинний ключ, іdentity): унікальний ідентифікатор перевірки. Генерується автоматично завдяки властивості IDENTITY.
    • check_date (DATE, NOT NULL): дата проведення перевірки.
    • result (NVARCHAR(50), NOT NULL): результат перевірки. 
    • sensor_id (INT, зовнішній ключ): ідентифікатор датчика, до якого належить перевірка.
Таблиця Events зберігає дані про події, що викликають сенсори. Її поля та обмеження полів: 
    • event_id (INT, PRIMARY KEY, IDENTITY): унікальний ідентифікатор події, автоматично генерується.
    • event_time (DATETIME, NOT NULL): зберігається час і дата події.
    • severity (INT, NOT NULL): описує важливість, рівень серйозності події.
    • data_id (INT, FOREIGN KEY): ідентифікатор даних, що викликали подію.
Таблиця Notifications зберігає інформацію про сповіщення. Її поля та обмеження полів: 
    • notification_id (INT, PRIMARY KEY, IDENTITY): унікальний ідентифікатор сповіщення.
    • message (NVARCHAR(255), NOT NULL): містить текст сповіщення.
    • notification_type (NVARCHAR(30), NOT NULL): тип сповіщення.
    • formation_time (DATETIME, NOT NULL): зберігає дату і час створення сповіщення.
    • user_id (INT, FOREIGN KEY): ідентифікатор користувача, що отримав сповіщення.
    • event_id (INT, FOREIGN KEY): ідентифікатор події, на яку посилається сповіщення.
3.5 Створити діаграму структури БД.

Рисунок 2 - Діаграма структури БД
     
3.6 Розробити функції роботи з БД.
Створено GasLeakDbContext клас, який дозволяє взаємодіяти з базою даних. Він містить набір властивостей типу DbSet<T>, які представляють таблиці в базі даних.
Також було створено сервіси (наприклад, UserService, LocationService, SensorService та інші), які інкапсулюють логіку для взаємодії з базою даних, включаючи додавання, оновлення, видалення та отримання даних. Вони взаємодіють з DbContext для виконання операцій над даними.
Контролери (наприклад, UserController, LocationController, SensorController та інші) отримують запити від клієнтів і викликають відповідні методи у сервісах для виконання операцій над базою даних.
Entity Framework дозволяє автоматично або вручну створювати схему бази даних через механізм міграцій.
3.7 Розробити API для взаємодії серверної частини з клієнтами.
REST API реалізовано за допомогою ASP.NET Core, де контролери відповідають за обробку HTTP-запитів. Реалізовано основні операції отримання, додавання, оновлення та видалення даних для усіх таблиць бази даних. Також додано додаткові функції для взаємодії з даними.
3.8 Створити специфікацію розробленого API.
У таблиці 1 представлено специфікацію розробленого АРІ.
Таблиця 1 – Специфікація АРІ
Метод       Маршрут                             Опис
GET         api/users                           Отримати список всіх користувачів.
GET         api/users/{id}                      Отримати певного користувача.
POST        api/users                           Створити нового користувача.
PUT         api/users/{id}                      Оновити обраного користувача.
DELETE      api/users/{id}                      Видалити обраного користувача.
GET         api/users/location/{locationId}     Отримати користувачів за обраною локацією.
GET         api/locations                       Отримати всі локації.
GET         api/locations/{id}                  Знайти локацію за id.
POST        api/locations                       Створити нову локацію.
PUT         api/locations/{id}                  Оновити обрану локацію.
DELETE      api/locations/{id}                  Видалити обрану локацію.
GET         api/locations/floor/{floor}         Отримати локації за обраним поверхом.
GET         api/locations/type/{type}           Отримати локації за обраним типом.
GET         api/sensors                         Отримати всі сенсори.
GET         api/sensors/{id}                    Отримати певний сенсор.
POST        api/sensors                         Додати новий сенсор.
PUT         api/sensors/{id}                    Оновити обраний сенсор.
DELETE      api/sensors/{id}                    Видалити обраний сенсор.
GET         api/sensors/status/{status}         Отримати сенсори з обраним статусом.
GET         api/sensors/location/{locationId}   Отримати сенсори на вказаній локації.
GET         api/checks                          Отримати всі перевірки.
GET         api/checks/{id}                     Отримати певну перевірку.
POST        api/checks                          Додати нову перевірку.
PUT         api/checks/{id}                     Оновити інформацію про перевірку.
DELETE      api/checks/{id}                     Видалити інформацію про перевірку.
GET         api/checks/date/{date}              Отримати всі перевірки за обраною датою.
GET         api/checks/result/{result}          Отримати всі перевірки з обраним результатом.
GET         api/checks/sensor/{sensorId}        Отримати всі перевірки для обраного сенсора.
GET         api/data                            Отримати всі дані з сенсорів.
GET         api/data/{id}                       Отримати певні дані.
POST        api/data                            Створити нові дані.
PUT         api/data/{id}                       Оновити дані з сенсора.
DELETE      api/data/{id}                       Видалити дані, отримані з сенсора.
GET         api/events                          Отримати всі події.
GET         api/events/{id}                     Отримати певну подію.
POST        api/events                          Створити нову подію.
PUT         api/events/{id}                     Оновити обрану подію.
DELETE      api/events/{id}                     Видалити обрану подію.
GET         api/events/severity/{severity}      Отримати всі події з обраною важливістю.
GET         api/notifications                   Отримати всі сповіщення.
GET         api/notifications/{id}              Отримати певне сповіщення.
POST        api/notifications                   Створити нове сповіщення.
PUT         api/notifications/{id}              Оновити обране сповіщення.
DELETE      api/notifications/{id}              Видалити обране сповіщення.
GET         api/notifications/type/{type}       Отримати всі сповіщення за вказаним типом.
     
4. Тестування розроблених функцій серверної частини.
Swagger UI було налаштовано у проєкті та використано для тестування розроблених функцій серверної частини. Swagger автоматично генерує інтерфейс для тестування API.
5. Навести фрагменти програмного коду з логікою взаємодії серверної частини з БД.
Приклад коду, що наведено у додатку Б, демонструє реалізацію моделі даних у серверній частині, яка використовується для взаємодії з базою даних через ORM Entity Framework. Клас Location є відображенням таблиці в базі даних. У класі визначено поля (location_id, name, location_type, floor, area) та атрибути ([Key], [Required], [MaxLength]) для визначення правил зберігання даних, таких як первинні ключі, обов’язкові поля, обмеження на довжину тексту та інше. У моделі визначено зв'язки між таблицями за допомогою навігаційних властивостей.
Також у додатку Б наведено приклади реалізації деяких CRUD-операцій (створення, читання, оновлення) за допомогою ORM Entity Framework.
6. Навести фрагменти програмного коду з логікою взаємодії серверної частини з клієнтами.
У додатку В наведено фрагменти коду, що обробляють запити клієнтів через HTTP API, викликаючи відповідні методи сервісного шару для роботи з базою даних. 
7. Посилання на відеозапис з тестуванням функціональності серверної частини (YouTube):
https://youtu.be/x124vrhQrtI 
8. Посилання на репозиторій проєкту (GitHub):
https://github.com/NureLysenkoAnna/arkpz-pzpi-22-6-lysenko-anna/tree/main/Task2
9. Висновки:
У результаті виконання лабораторної роботи було створено базу даних для серверної частини  програмної системи та прикладного програмного інтерфейсу (API).
     
ДОДАТОК А
UML діаграма прецедентів для серверної частини системи  

Рисунок А.1 - UML діаграма прецедентів

ДОДАТОК Б
Фрагменти програмного коду з логікою взаємодії серверної частини з БД

1	public class Location
2	{
3	    [Key]
4	    public int location_id { get; set; }
5	
6	    [Required]
7	    [MaxLength(100)]
8	    public string name { get; set; }
9	
10	    [Required]
11	    [MaxLength(50)]
12	    public string location_type { get; set; }
13	
14	    [Required]
15	    public int floor { get; set; }
16	
17	    public double? area { get; set; } 
18	
19	    [JsonIgnore]
20	    public ICollection<User>? Users { get; set; }
21	
22	    [JsonIgnore]
23	    public ICollection<Sensor>? Sensors { get; set; }
24	}
25
26
27
28	public async Task<List<Location>> GetAllLocationsAsync()
29	{
30	    return await _context.Locations.ToListAsync();
31	}
32	
33	public async Task<Location> GetLocationByIdAsync(int locationId)
34	{
35	    return await _context.Locations.FindAsync(locationId);
36	}
37	
38	public async Task<Location> AddLocationAsync(Location location)
39	{
40	    _context.Locations.Add(location);
41	    await _context.SaveChangesAsync();
42	    return location;
43	}

ДОДАТОК В
Фрагменти програмного коду з логікою взаємодії серверної частини з клієнтами

1	[HttpGet]
2	[SwaggerOperation(Summary = "Отримати всі локації.")]
3	public async Task<ActionResult<IEnumerable<Location>>> GetLocations()
4	{
5	    var locations = await _locationService.GetAllLocationsAsync();
6	    return Ok(locations);
7	}
8
9	[HttpGet("{id}")]
10	[SwaggerOperation(Summary = "Знайти локацію за id.")]
11	public async Task<ActionResult<Location>> GetLocationById(int id)
12	{
13	    var location = await _locationService.GetLocationByIdAsync(id);
14	    if (location == null)
15	    {
16	        return NotFound($"Локація з ID {id} не знайдена");
17	    }
18	    return Ok(location);
19	}
20
21	[HttpPost]
22	[SwaggerOperation(Summary = "Створити нову локацію.")]
23	public async Task<IActionResult> AddLocation([FromBody] Location location)
24	{
25	    if (location == null)
26	    {
27	        return BadRequest("Invalid location data.");
28	    }
29
30	    location.location_id = 0;
31
32	    var addedLocation = await _locationService.AddLocationAsync(location);
33	    return CreatedAtAction(nameof(GetLocationById), new { id = addedLocation.location_id }, addedLocation);
34	}
