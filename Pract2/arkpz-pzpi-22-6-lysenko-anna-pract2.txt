МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ  УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»


ЗВІТ
з практичного заняття №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»





Виконала	                     Перевірив
ст. гр. ПЗПІ-22-6	             ст. викладач
Лисенко А.М.			         Сокорчук І.П.






Харків 2024
1 МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ
2. Мета роботи:
Вивчити основні методи рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення якості програмного коду.
3. Хід роботи:
3.1. Для виконання другого практичного заняття було обрано три методи рефакторингу: Hide Method, Split Temporary Variable, Replace Temp with Query.
3.2. Після вивчення обраних методів було обрано частини коду з власних проєктів, як приклади, що зможуть проілюструвати використання методів.
3.3. Створено презентацію, що містить аналіз обраних методів рефакторингу та їх практичне використання. Інформація та кодові приклади зі слайдів презентації представлено нижче:
Вступ:
Методи рефакторингу – це інструменти для створення «чистого коду», що є основою для надійних, масштабованих і підтримуваних програмних систем. Використовуючи їх, можна забезпечити високу якість проєктів, зменшуючи ризик накопичення технічного боргу.
У презентації буде розібрано та визначено переваги застосування трьох методів рефакторингу:
• Hide Method;
• Split Temporary Variable;
• Replace Temp with Query.
Метод Hide Method:
Hide Method передбачає приховування деталей реалізації, які не є частиною публічного інтерфейсу класу або модуля. Такі методи залишаються доступними лише для внутрішнього використання.
Основна ідея – зменшити «видимість» коду, який не повинен бути викликаний або змінений зовнішніми клієнтами.
Випадки застосування:
• Якщо метод використовується лише всередині класу/модуля і не має сенсу бути доступним зовні.
• Коли потрібно мінімізувати публічний інтерфейс класу для спрощення його використання.
• Для дотримання принципу інкапсуляції, одного з ключових принципів ООП.
Визначення проблем коду:
    1	class UserManager {
    2	    constructor() {
    3	        this.users = [];
    4	    }
    5	
    6	    addUser(user) {
    7	        if (this.validateUser(user)) {
    8	            this.users.push(user);
    9	            console.log("User added successfully.");
    10	        } else {
    11	            console.log("Invalid user.");
    12	        }
    13	    }
    14	
    15	    validateUser(user) {
    16	        return user && user.name && user.email;
    17	    }
    18
    19	    listUsers() {
    20	        console.log("User List:");
    21	        this.users.forEach(user => console.log(`${user.name} (${user.email})`));
    22	    }
    23	}
Застосування Hide Method:
Робимо метод validateUser приватним, щоб він використовувався тільки в межах класу UserManager, який його містить, і, таким чином, жодний інший клас не буде мати доступ до нього. Завдяки застосуванню методу Hide Method, внутрішні деталі класів та модулів стають інкапсульованими.
Тепер клієнти можуть взаємодіяти з класом лише через методи addUser і listUsers, що мінімізує ризик помилок і спрощує використання класу. Зміни в логіці методу #validateUser не впливатимуть на зовнішній код, тому що його викликає лише метод addUser.
Код після рефакторингу:
    1	class UserManager {
    2	    constructor() {
    3	        this.users = [];
    4	    }
    5
    6	    addUser(user) {
    7	        if (this.#validateUser(user)) {
    8	            this.users.push(user);
    9	            console.log("User added successfully.");
    10	        } else {
    11	            console.log("Invalid user.");
    12	        }
    13	    }
    14	
    15	    // Робимо метод приватним
    16	    #validateUser(user) {
    17	        return user && user.name && user.email;
    18	    }
    19
    20	    listUsers() {
    21	        console.log("User List:");
    22	        this.users.forEach(user => console.log(`${user.name} (${user.email})`));
    23	    }
    24	}
    Метод Split Temporary Variable:
    Метод Split Temporary Variable полягає в розділенні тимчасової змінної, якщо вона використовується для зберігання різних значень або виконує кілька ролей у межах одного блоку коду. Кожна змінна повинна відповідати лише за одне значення або одну роль.
Випадки застосовування:
• Коли змінна використовується для зберігання різних значень у межах однієї функції або блоку коду.
• Коли значення змінної змінюється кілька разів із різними цілями.
• Коли потрібно підвищити читабельність і безпеку коду.
Визначення проблем коду:
    1	function calculateAreaProperties(radius, height) {
    2	    let temp = Math.PI * radius * radius;
    3	    console.log(`Base Area: ${temp}`);
    4
    5	    temp = 2 * Math.PI * radius * height;
    6	    console.log(`Lateral Surface Area: ${temp}`);
    7
    8	    temp = temp + 2 * Math.PI * radius * radius;
    9	    console.log(`Total Surface Area: ${temp}`);
    10	
    11	    temp = Math.PI * radius * radius * height;
    12	    console.log(`Volume: ${temp}`);
    13	}
Застосування Split Temporary Variable:
Завдяки чіткому розділенню відповідальностей, кожен елемент коду стає простішим для розуміння. Метод Split Temporary Variable усуває двозначність змінних, забезпечуючи зрозумілість їх призначення.
Кожна змінна використовується для зберігання тільки одного значення, і це значення чітко визначено її назвою. Усувається двозначність і забезпечується, що кожна змінна має чітко визначену роль, яку легко зрозуміти при читанні коду.
Тепер змінна виконує одну роль і не змінюється в процесі виконання, що виключає ризик випадкового переписування значень або використання неправильних даних. У коді після рефакторингу кожна змінна зберігає своє значення незалежно від інших, це дозволяє уникнути ситуацій, коли одне значення може перезаписати інше.
Код після рефакторингу:
    1	function calculateAreaProperties(radius, height) {
    2	    const baseArea = Math.PI * radius * radius;
    3	    console.log(`Base Area: ${baseArea}`);
    4
    5	    const lateralSurfaceArea = 2 * Math.PI * radius * height;
    6	    console.log(`Lateral Surface Area: ${lateralSurfaceArea}`);
    7
    8	    const totalSurfaceArea = lateralSurfaceArea + 2 * baseArea;
    9	    console.log(`Total Surface Area: ${totalSurfaceArea}`);
    10
    11	    const volume = baseArea * height;
    12	    console.log(`Volume: ${volume}`);
    13	}
Метод Replace Temp with Query:
Метод Replace Temp with Query передбачає заміну тимчасової змінної викликом функції або методу, який обчислює це значення. Замість того щоб зберігати результат у змінній, код виконує потрібний розрахунок у місці використання.
Випадки застосування:
• Коли значення змінної є результатом функції або обчислення, яке не потребує проміжного зберігання.
• Якщо значення змінної використовується лише один або кілька разів і її простіше замінити викликом функції.
• Коли потрібно уникнути зайвих змінних, зробити код чистішим.
Визначення проблем коду:
    1	function isWeekend(date) {
    2	    let dayOfWeek = date.getDay();
    3	    let isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    4	    return isWeekend;
    5	}
Код після рефакторингу:
Після видалення зайвих змінних було знижено ризик неправильного використання коду. Метод Replace Temp with Query дозволив уникнути дублювання обчислень і зайвих залежностей між змінними.
Після рефакторингу відразу повертається результат порівняння, без створення проміжних змінни.
    1	function isWeekend(date) {
    2	    return date.getDay() === 0 || date.getDay() === 6;
    3	}
Інструменти для автоматичного рефакторингу:
IntelliJ IDEA пропонує широкий набір інструментів для поліпшення структури коду та підтримки його чистоти.
Вбудований рефакторинг містить: автоматичні операції, як-от перейменування змінних, методів або класів, розбиття великих методів, інлайнування тимчасових змінних, пошук залежностей: забезпечує, щоб зміни не порушували роботу інших частин коду.
IntelliJ IDEA підтримує різні мови: Java, Kotlin, Python, JavaScript та багато інших. 
Висновки:
Методи рефакторингу, такі як Hide Method, Split Temporary Variable, і Replace Temp with Query, сприяють покращенню якості програмного коду. Їх використання допомагає зробити код більш зрозумілим, легшим у підтримці та менш схильним до помилок.
Загалом рефакторинг допомагає уникати «технічного боргу», який може накопичуватися в проєктах через складність або неякісність коду.
Представлені методи рефакторингу впроваджують найкращі практики програмування: чітка інкапсуляція (Hide Method), простота і прозорість змінних (Split Temporary Variable), мінімізація зайвих залежностей (Replace Temp with Query).
Список використаних джерел:
• Catalog of Refactoring. Refactoring and Design Patterns. URL: https://refactoring.guru/refactoring/catalog.
• Code refactoring | IntelliJ IDEA. URL: https://www.jetbrains.com/help/idea/refactoring-source-code.html.
• Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.

4. Висновок: 
Під час виконання практичної роботи було вивчено основні методи рефакторингу коду, на основі реальних прикладів з власних програмних проєктів було детально розглянуто та опрацьовано методи: Hide Method, Split Temporary Variable, Replace Temp with Query. Також було ідентифікувано проблеми в коді та використано відповідні методи рефакторингу для покращення якості програмного коду. Всі приклади коду та загальні принципи застосування обраних методів рефакторингу зібрано у розробленій презентації. Повні слайди презентації наведено у додатку А.
5. Посилання на відео з виступом (YouTube):
https://youtu.be/9hTnGe6Pngs 
6. Посилання на репозиторій (GitHub):
https://github.com/NureLysenkoAnna/arkpz-pzpi-22-6-lysenko-anna/tree/main/Pract2 

ДОДАТОК А
Слайди презентації

Рисунок А.1 – Слайд з темою виступу

Рисунок А.3 – Слайд «Метод Hide Method»

Рисунок А.4 – Слайд «Визначення проблем коду»

Рисунок А.5 – Слайд «Застосування Hide Method»

Рисунок А.6 – Слайд «Код після рефакторингу»

Рисунок А.7 – Слайд «Метод Split Temporary Variable»

Рисунок А.8 – Слайд «Визначення проблем коду»

Рисунок А.9 – Слайд «Застосування Split Temporary Variable»

Рисунок А.10 – Слайд «Код після рефакторингу»

Рисунок А.11 – Слайд «Метод Replace Temp with Query»

Рисунок А.12 – Слайд «Визначення проблем коду»

Рисунок А.13 – Слайд «Код після рефакторингу»

Рисунок А.14 – Слайд «Інструменти для автоматичного рефакторингу»

Рисунок А.15 – Слайд «Висновки»

Рисунок А.16 – Слайд «Список використаних джерел»
